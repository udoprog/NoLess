/*	SimpleXML 0.5 Beta	Written By John-John Tedro (pentropia at gmail dot com)		Concept: SimpleXML is originally a oncept developed related to PHP.	I realised that the simplicity of SimpleXML is something that would be greatly	appreciated when writing pages with DOM relying content because compared to the	DOM traversal functionality that is mostly focused on portability. SimpleXML is	focusing on accessing the correct content you are seaking with as few lines of	code as possible.		Example.xml:		var xmlString = "<root>	"+ "			<child attr="value">"+ "				<subchild>		" + "					content		"+ "				</subchild>		"+ "			</child>			"+ "			<child>				"+ "				<subchild>		"+ "					content		"+ "				</subchild>		"+ "			</child>			"+ "		</root>";				var sxe = SimpleXML.load_text( xmlString );				// first Subchild could be accessed the following way.		// '$' simply means 'access all textnodes' contained in element.		alert( sxe.root[0].child[0].subchild[0].$[0][value] );				// To access child's attribute 'attr' value		alert( sxe.root[0].child[0]['@']['attr'] );				// You can still axxess the original DOM by using '%':		alert( sxe.root[0]['%'] );				//! spath ! experimental, may change without notice.		//spath 'simplepath' is used to in a simple way access certain elements.		//example:		alert( sxe.spath("/root/child/subchild")['$'] );		// would alert the value of the 'first' subchild nestled in the 'first' child node in root.			TODO:	Code is all messy, got to clean it properly.	spath method is experimantal, 		*/SimpleXMLAttr.INDEX_TAG				= '@';SimpleXMLNode.XPATH_REGEX = /\/([a-zA-Z]+)/g;SimpleXMLTextNode.IGNORE_TEXT_REGEX	= /^[\s]*$/;SimpleXMLTextNode.INDEX_TAG			= '$';/*	To keep track of DOM attributes.*/function SimpleXMLAttr() {	this.length = 0;	this.attr = new Array();	return this;}SimpleXMLAttr.prototype.load_attr = function( attr ) {	if ( !attr ) return this;	this.length = attr.length;	if ( !this.length ) return this;		for ( var i = 0 ; i < this.length ; i++ )		this[ attr[i].nodeName ] = attr[i].nodeValue;		return this;}; SimpleXMLAttr.prototype.toString = function() { return "[Object SimpleXMLAttr]"; };/*	To keep track of DOM nodes.*/function SimpleXMLNode() {	this[ SimpleXMLAttr.INDEX_TAG ] = null;	this[ SimpleXMLTextNode.INDEX_TAG ] = null;}; SimpleXMLNode.prototype.toString = function() { return "[Object SimpleXMLNode]"; };SimpleXMLNode.prototype.spath = function( spath ) {	var Node = this;		while ( SimpleXMLNode.XPATH_REGEX.exec( spath ) ) {		if ( Node[RegExp.$1] )			Node = Node[RegExp.$1][0];		else {			Node = null;			break;		}	}		var sxeSpathCollection = {		'$': ( Node['$'] ? unescape( Node['$'][0]['value'] ) : false ),		'%': ( Node['%'] ? Node['%'] : false ),		'@': ( Node['@'] ? Node['@'] : false ),		'sxe': Node,		toString: function() { return "[Object SimpleXMLSpathCollection]"; }	}		return sxeSpathCollection;}function SimpleXMLTextNode() {	this['value'] = null;};SimpleXMLTextNode.prototype.load_text = function( text ) {	this['value'] = text;	return this;}/*	To utilise other objects.*/var SimpleXML = {	NODE_ELEMENT: 1,	NODE_TEXT: 3,	DOM_TAG: '%',	load: function( xml ) {		var wArray = new Array();		var xml = xml;				var sxNode = new SimpleXMLNode();				do {			if ( !xml ) break;						var type = xml.nodeType;						switch ( type ) {				case SimpleXML.NODE_ELEMENT:					var name = ( xml.tagName ) ? xml.tagName.toLowerCase() : null ;					var attr = ( xml.attributes ) ? xml.attributes : null ;										if ( !sxNode[ name ] ) sxNode[ name ] = new Array();						var length = sxNode[ name ].length;										sxNode[ name ][ length ] =								new Array();					sxNode[ name ][ length ] =								SimpleXML.load( xml.firstChild );					sxNode[ name ][ length ][ SimpleXMLAttr.INDEX_TAG ] =	new SimpleXMLAttr().load_attr( attr );					sxNode[ name ][ length ][ SimpleXML.DOM_TAG ] =			xml;					break;				case SimpleXML.NODE_TEXT:					var value = xml.nodeValue;										if ( SimpleXMLTextNode.IGNORE_TEXT_REGEX.exec( value ) ) break;										var tag = SimpleXMLTextNode.INDEX_TAG;										if ( !sxNode[ tag ] ) sxNode[ tag ] = new Array();						var length = sxNode[ tag ].length;										sxNode[ tag ][ length ] =	new SimpleXMLTextNode().load_text( value );					break;			}						} while ( xml = xml.nextSibling );				return sxNode;	},		load_text: function( xml_string ) {		var xml = strToXml( xml_string );		return this.load( xml );	}};