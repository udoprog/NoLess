/** Javascript Module - Container *	EARLY STAGE ALPHA	Changes *	08:32 2007-01-06 - method setElementById added. *	16:57 11/01/2007 - Point changed to point at Container Object instead of element. *	17:55 11/01/2007 - FIX! All elements must be replaced when loading ocse ( since it's done after the page loads). *	18:06 2007-01-12 - FIX! Point has to be set when object is. *	23:05 2007-01-14 - FIX! Rewrite, adjust framework, new names of methods. */var NTextElement = function( content ) {	var nTextElement = new NNodeElement( $T( content ) );		nTextElement.toString = function() { return "[NoLess TextElement]"; };	nTextElement.isNode = false;		return nTextElement;};var NNodeElement = function( tag , content ) {	if ( Try.object( tag ) ) {		var nNodeElement = tag;		this.tag = tag.tagName;	} else throw new Error( "Unable to determine content type" );		nNodeElement.isNode = true;		nNodeElement.frame = false;		/* To lock element */	nNodeElement.locked = false;	nNodeElement.lock = function() { this.locked = true; return this; };	nNodeElement.unlock = function() { this.locked = false; return this; };		/*		NElement.append			@1 element to append.					Returns NElement performing the appendation.	*/	nNodeElement.append = function( element ) {		if ( this.locked ) return this;					this.appendChild( element );		return this;	}		/*		NElement.remove			@1 element to remove.					Returns NElement performing the removing operation.	*/	nNodeElement.remove = function( element ) {		if ( this.locked ) return this;				this.removeChild( element );		return this;	}		nNodeElement.removeMe = function() {		if ( this.locked ) return this;				this.parentNode.removeChild( this );		return this;	}		/*		NElement.replace			@1 element to replace NElement with.					Returns new overwriting NElement	*/	nNodeElement.replace = function( nNodeElement ) {		if ( this.locked ) return this;				if ( !this.parentNode ) return false;		this.parentNode.replaceChild( nNodeElement , this );				return nNodeElement;	}		/*		NElement.digest			@1 element to 'digest'						! Digest means to simply take all element children and append them to oneself.					Returns active NElement	*/	nNodeElement.digest = function( element ) {		if ( this.locked ) return this;				var attr = null;		for ( var i = 0 ; attr = element.attributes[i++] ; ) {			this.setAttribute( attr.nodeName , attr.nodeValue );		}
				if ( !element.firstChild ) return this;
				Make.siblingIterator(
			element.firstChild, this , 			function( node , parent ) {
				parent.append( node );
				
				return false;			}, false		)				return this;	}		/*		NElement.reset			No Arguments						! removes all content in NElement					Returns active NElement	*/	nNodeElement.reset = function() {		if ( this.locked ) return this;				while ( this.firstChild )			this.removeChild( this.firstChild );		return this;	}		/*		NElement.copy			No Arguments					Returns copy of active NElement	*/	nNodeElement.copy = function() {		return new NElement( this.cloneNode( true ) );	}		/*		NElement.copy			@1 String with text to append.						! Creates NTextElement and appends it to active NElement					Returns active NElement	*/	nNodeElement.appendText = function( text ) {		if ( this.locked ) return this;		this.append( $T( text ) );		return this;	}		/*		NElement.setFrame			@1 Boolean indicating if frame or not.					Returns active NElement	*/	nNodeElement.setFrame = function( isFrame ) {		if ( this.locked ) return this;		this.frame = isFrame;		return this;	}		/*		NElement.setTarget			@1 String representing id of target element.					Returns active NElement	*/	nNodeElement.setTarget = function( target ) {		if ( this.locked ) return this;		this.target = target;		return this;	}		/*		NElement.Target			No Arguments					Returns active NElement's target element	*/	nNodeElement.Target = function() {		if ( this.target )			var target = $( this.target );				if ( !target )			alert( "'target' invalid, id could not be found." );				return ( target ? target : this );	}		/*		NElement.Frame			@1 Boolean indicating if seek should skip any possible target redirections.					Returns null on fail or validated Frame	*/	nNodeElement.Frame = function( skipTarget ) {		var wGEnt = this;				do {			if ( wGEnt.target && !skipTarget ) {				if ( wGEnt.Target().Frame( true ) != wGEnt.Frame( true ) )					wGEnt = wGEnt.Target();			}						if ( wGEnt.frame ) return wGEnt;		} while ( wGEnt.parentNode ? wGEnt = wGEnt.parentNode : wGEnt.frame = true );				return null;	}		nNodeElement.addEvent = function( eType , eCall , ePhase ) {		var self = this;		function exeEvent( evt ) {			var evt = ( evt || event );			stdEvt = new StdEvent( evt , self );			eCall( stdEvt );			return stdEvt.wreturn;		}				if ( this.addEventListener ) { this.addEventListener( eType , exeEvent , ePhase ); } 		else if ( this.attachEvent ) { this.attachEvent( "on" + eType , exeEvent , ePhase ); }				return this;	};	nNodeElement.removeEvent = function( eType , eCall , ePhase ) {		var self = this;		function exeEvent() {};				if ( this.removeEventListener ) { this.removeEventListener( eType , exeEvent , ePhase ); } 		else if ( this.detachEvent ) { this.detachEvent( "on" + eType , exeEvent , ePhase ); }				return this;	};		nNodeElement.toString = function() { return "[NoLess NodeElement]"; };		return nNodeElement;}var NElement = function( xml ) {	var xml = xml;		if ( !xml ) return false;		if ( Try.string( xml ) ) {		return new NNodeElement( $E( xml ) );	}		var type = xml.nodeType;		if ( type == 1 ) {		return new NNodeElement( xml );	} else if ( type == 3 ) {		if ( NElement.IGNORE_TEXT_REGEX.test( xml.nodeValue ) ) return false;		NElement.CLEAN_TEXT_REGEX.exec( xml.nodeValue );				return new NTextElement( RegExp.$1 );	}		return false;}NElement.IGNORE_TEXT_REGEX = /^[\s]*$/;NElement.CLEAN_TEXT_REGEX = /^\s*(.*)\s*$/;NElement.STRING_TAG = '$';